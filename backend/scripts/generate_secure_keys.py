#!/usr/bin/env python3
"""
Secure key generation script using OpenSSL standards
Generates production-ready cryptographic keys for all environments
"""
import os
import subprocess
import base64
import secrets
from pathlib import Path
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

def run_openssl_command(command):
    """Run OpenSSL command and return output"""
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"OpenSSL command failed: {e}")
        print(f"Error output: {e.stderr}")
        raise

def generate_openssl_rsa_keys():
    """Generate RSA key pair using OpenSSL"""
    print("üîê Generating RSA key pair using OpenSSL...")
    
    # Create temporary files for keys
    temp_dir = Path("temp_keys")
    temp_dir.mkdir(exist_ok=True)
    
    private_key_file = temp_dir / "private_key.pem"
    public_key_file = temp_dir / "public_key.pem"
    
    try:
        # Generate private key using OpenSSL
        run_openssl_command(f"openssl genpkey -algorithm RSA -out {private_key_file} -pkcs8 -aes256 -pass pass:temp_password")
        
        # Extract public key
        run_openssl_command(f"openssl pkey -in {private_key_file} -passin pass:temp_password -pubout -out {public_key_file}")
        
        # Read and return keys
        with open(private_key_file, 'r') as f:
            private_key_pem = f.read()
        
        with open(public_key_file, 'r') as f:
            public_key_pem = f.read()
        
        return private_key_pem, public_key_pem
        
    finally:
        # Clean up temporary files
        if private_key_file.exists():
            private_key_file.unlink()
        if public_key_file.exists():
            public_key_file.unlink()
        temp_dir.rmdir()

def generate_secure_symmetric_key():
    """Generate secure symmetric encryption key using Fernet"""
    print("üîê Generating Fernet encryption key...")
    return Fernet.generate_key().decode()

def generate_jwt_secret():
    """Generate secure JWT secret using cryptographically secure random"""
    print("üîê Generating JWT secret key...")
    # Generate 256-bit (32 bytes) random secret
    return base64.urlsafe_b64encode(secrets.token_bytes(32)).decode()

def generate_session_secret():
    """Generate secure session secret"""
    print("üîê Generating session secret key...")
    # Generate 256-bit (32 bytes) random secret
    return base64.urlsafe_b64encode(secrets.token_bytes(32)).decode()

def derive_key_from_password(password: str, salt: bytes = None) -> str:
    """Derive encryption key from password using PBKDF2"""
    if salt is None:
        salt = secrets.token_bytes(32)
    
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,  # OWASP recommended minimum
    )
    key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
    return key.decode()

def create_env_template(keys_dict):
    """Create .env template with generated keys"""
    template = f"""# Security Configuration - PRODUCTION READY
# Generated by secure key generation script
# CRITICAL: Keep these keys secure and never commit to version control

# Database Configuration
DATABASE_URL=sqlite:///./crm_production.db
# For PostgreSQL: DATABASE_URL=postgresql://user:password@localhost:5432/crm_db

# JWT Configuration (Alternative to standard JWT - see security notes)
JWT_SECRET_KEY={keys_dict['jwt_secret']}
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=15
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# Symmetric Encryption (Fernet)
SECRET_ENCRYPTION_KEY={keys_dict['fernet_key']}

# Session Management
SESSION_SECRET_KEY={keys_dict['session_secret']}

# RSA Key Pair (OpenSSL Generated)
RSA_PRIVATE_KEY_PEM={keys_dict['private_key_base64']}
RSA_PUBLIC_KEY_PEM={keys_dict['public_key_base64']}

# Security Settings
SECURITY_LEVEL=high
ENFORCE_HTTPS=true
SECURE_COOKIES=true
CSRF_PROTECTION=true
RATE_LIMITING=true

# Redis Configuration (for distributed sessions)
# REDIS_URL=redis://localhost:6379/0

# Alternative Authentication Methods (More Secure than JWT)
# Consider implementing these for enhanced security:
USE_OAUTH2_PKCE=true
USE_WEBAUTHN=true
USE_TOTP_MFA=true

# Certificate-based Authentication (Future Implementation)
# ENABLE_CERT_AUTH=true
# CLIENT_CERT_REQUIRED=true
"""
    return template

def generate_oauth2_encryption_key():
    """Generate OAuth2 PKCE encryption key using Fernet"""
    print("üîê Generating OAuth2 PKCE encryption key...")
    return Fernet.generate_key().decode()

def generate_oauth2_client_id():
    """Generate secure OAuth2 client ID"""
    print("üîê Generating OAuth2 client ID...")
    return f"crm_{secrets.token_urlsafe(16)}"

def create_oauth2_env_template(keys_dict):
    """Create .env template with OAuth2 PKCE configuration"""
    template = f"""# ========================================
# CRM OAuth2 PKCE Security Configuration
# ========================================
# Generated by secure key generation script
# CRITICAL: Keep these keys secure and never commit to version control

# Database Configuration
DATABASE_URL=sqlite:///./crm_production.db
# For PostgreSQL: DATABASE_URL=postgresql://user:password@localhost:5432/crm_db

# ========================================
# OAuth 2.0 with PKCE Configuration
# ========================================

# OAuth2 Encryption Key (for token encryption)
OAUTH2_ENCRYPTION_KEY={keys_dict['oauth2_encryption_key']}

# OAuth2 Server URLs
OAUTH2_AUTHORIZATION_URL=https://your-domain.com/auth/authorize
OAUTH2_TOKEN_URL=https://your-domain.com/auth/token
OAUTH2_USERINFO_URL=https://your-domain.com/auth/userinfo

# OAuth2 Token Configuration
OAUTH2_ACCESS_TOKEN_EXPIRE_MINUTES=60
OAUTH2_REFRESH_TOKEN_EXPIRE_DAYS=30
OAUTH2_AUTHORIZATION_CODE_EXPIRE_MINUTES=10

# OAuth2 Client Configuration
OAUTH2_DEFAULT_CLIENT_ID={keys_dict['oauth2_client_id']}
OAUTH2_ALLOWED_SCOPES=read,write,admin,sales,marketing,support
OAUTH2_REDIRECT_URIS=https://your-domain.com/auth/callback,http://localhost:3000/auth/callback

# ========================================
# Security Configuration
# ========================================

# Session Encryption Key
SECRET_ENCRYPTION_KEY={keys_dict['fernet_key']}

# Session Management
SESSION_SECRET_KEY={keys_dict['session_secret']}

# RSA Key Pair (OpenSSL Generated)
RSA_PRIVATE_KEY_PEM={keys_dict['private_key_base64']}
RSA_PUBLIC_KEY_PEM={keys_dict['public_key_base64']}

# Environment Settings
ENVIRONMENT=production
SECURE_COOKIES=true
HTTPS_ONLY=true
CORS_ORIGINS=https://your-domain.com,https://app.your-domain.com

# Security Settings
SECURITY_LEVEL=high
ENFORCE_HTTPS=true
CSRF_PROTECTION=true
RATE_LIMITING=true

# ========================================
# DEPRECATED JWT Configuration
# ========================================
# These are kept for reference but should NOT be used
# The system has been migrated to OAuth 2.0 with PKCE

# JWT_SECRET_KEY=DEPRECATED_USE_OAUTH2_PKCE
# JWT_ALGORITHM=DEPRECATED_USE_OAUTH2_PKCE
# JWT_ACCESS_TOKEN_EXPIRE_MINUTES=DEPRECATED_USE_OAUTH2_PKCE

# ========================================
# Advanced Security Features
# ========================================

# Multi-Factor Authentication
ENABLE_MFA=true
TOTP_ISSUER=CRM_Application

# WebAuthn/FIDO2 Support
ENABLE_WEBAUTHN=true
WEBAUTHN_RP_ID=your-domain.com
WEBAUTHN_RP_NAME=CRM Application

# Certificate-based Authentication
ENABLE_CERT_AUTH=false
CLIENT_CERT_REQUIRED=false

# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_REQUESTS_PER_MINUTE=60

# Audit and Logging
AUDIT_LOG_ENABLED=true
SECURITY_LOG_ENABLED=true
PERFORMANCE_MONITORING=true
"""
    return template

def generate_oauth2_keys():
    """Generate all OAuth2 PKCE related keys"""
    print("üöÄ Starting OAuth2 PKCE key generation...")
    
    keys = {}
    
    # Generate OAuth2 specific keys
    keys['oauth2_encryption_key'] = generate_oauth2_encryption_key()
    keys['oauth2_client_id'] = generate_oauth2_client_id()
    
    # Generate other required keys
    keys['fernet_key'] = generate_secure_symmetric_key()
    keys['session_secret'] = generate_session_secret()
    
    # Generate RSA key pair using OpenSSL
    try:
        private_key_pem, public_key_pem = generate_openssl_rsa_keys()
        keys['private_key_base64'] = base64.b64encode(private_key_pem.encode()).decode()
        keys['public_key_base64'] = base64.b64encode(public_key_pem.encode()).decode()
        print("‚úÖ RSA keys generated successfully")
    except Exception as e:
        print(f"‚ö†Ô∏è  OpenSSL not available, falling back to cryptography library")
        # Fallback to cryptography library
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_pem = private_key.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        keys['private_key_base64'] = base64.b64encode(private_pem).decode()
        keys['public_key_base64'] = base64.b64encode(public_pem).decode()
    
    return keys

def main():
    """Generate all security keys and create configuration"""
    print("üöÄ Starting secure key generation for CRM application...")
    print("üìã This will generate production-ready cryptographic keys using OpenSSL standards")
    
    # Generate all keys
    keys = {}
    
    # Generate RSA key pair using OpenSSL
    try:
        private_key_pem, public_key_pem = generate_openssl_rsa_keys()
        keys['private_key_base64'] = base64.b64encode(private_key_pem.encode()).decode()
        keys['public_key_base64'] = base64.b64encode(public_key_pem.encode()).decode()
        print("‚úÖ RSA keys generated successfully")
    except Exception as e:
        print(f"‚ö†Ô∏è  OpenSSL not available, falling back to cryptography library")
        # Fallback to cryptography library
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_pem = private_key.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        keys['private_key_base64'] = base64.b64encode(private_pem).decode()
        keys['public_key_base64'] = base64.b64encode(public_pem).decode()
    
    # Generate symmetric keys
    keys['fernet_key'] = generate_secure_symmetric_key()
    keys['jwt_secret'] = generate_jwt_secret()
    keys['session_secret'] = generate_session_secret()
    
    # Create .env file
    env_content = create_env_template(keys)
    
    # Write to .env.secure file (don't overwrite existing .env)
    env_file = Path("../.env.secure")
    with open(env_file, 'w') as f:
        f.write(env_content)
    
    print(f"‚úÖ Secure configuration written to {env_file}")
    print("\nüìã Next Steps:")
    print("1. Review the generated .env.secure file")
    print("2. Backup your current .env file")
    print("3. Rename .env.secure to .env")
    print("4. Restart your application")
    print("\n‚ö†Ô∏è  Security Notes:")
    print("- Keep these keys secure and never commit to version control")
    print("- Consider using environment-specific key management systems")
    print("- Rotate keys regularly (every 90 days recommended)")
    print("- Consider JWT alternatives for enhanced security")

if __name__ == "__main__":
    main()#!/usr/bin/env python3
"""
Secure key generation script using OpenSSL standards
Generates production-ready cryptographic keys for all environments
"""
import os
import subprocess
import base64
import secrets
from pathlib import Path
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

def run_openssl_command(command):
    """Run OpenSSL command and return output"""
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"OpenSSL command failed: {e}")
        print(f"Error output: {e.stderr}")
        raise

def generate_openssl_rsa_keys():
    """Generate RSA key pair using OpenSSL"""
    print("üîê Generating RSA key pair using OpenSSL...")
    
    # Create temporary files for keys
    temp_dir = Path("temp_keys")
    temp_dir.mkdir(exist_ok=True)
    
    private_key_file = temp_dir / "private_key.pem"
    public_key_file = temp_dir / "public_key.pem"
    
    try:
        # Generate private key using OpenSSL
        run_openssl_command(f"openssl genpkey -algorithm RSA -out {private_key_file} -pkcs8 -aes256 -pass pass:temp_password")
        
        # Extract public key
        run_openssl_command(f"openssl pkey -in {private_key_file} -passin pass:temp_password -pubout -out {public_key_file}")
        
        # Read and return keys
        with open(private_key_file, 'r') as f:
            private_key_pem = f.read()
        
        with open(public_key_file, 'r') as f:
            public_key_pem = f.read()
        
        return private_key_pem, public_key_pem
        
    finally:
        # Clean up temporary files
        if private_key_file.exists():
            private_key_file.unlink()
        if public_key_file.exists():
            public_key_file.unlink()
        temp_dir.rmdir()

def generate_secure_symmetric_key():
    """Generate secure symmetric encryption key using Fernet"""
    print("üîê Generating Fernet encryption key...")
    return Fernet.generate_key().decode()

def generate_jwt_secret():
    """Generate secure JWT secret using cryptographically secure random"""
    print("üîê Generating JWT secret key...")
    # Generate 256-bit (32 bytes) random secret
    return base64.urlsafe_b64encode(secrets.token_bytes(32)).decode()

def generate_session_secret():
    """Generate secure session secret"""
    print("üîê Generating session secret key...")
    # Generate 256-bit (32 bytes) random secret
    return base64.urlsafe_b64encode(secrets.token_bytes(32)).decode()

def derive_key_from_password(password: str, salt: bytes = None) -> str:
    """Derive encryption key from password using PBKDF2"""
    if salt is None:
        salt = secrets.token_bytes(32)
    
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,  # OWASP recommended minimum
    )
    key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
    return key.decode()

def create_env_template(keys_dict):
    """Create .env template with generated keys"""
    template = f"""# Security Configuration - PRODUCTION READY
# Generated by secure key generation script
# CRITICAL: Keep these keys secure and never commit to version control

# Database Configuration
DATABASE_URL=sqlite:///./crm_production.db
# For PostgreSQL: DATABASE_URL=postgresql://user:password@localhost:5432/crm_db

# JWT Configuration (Alternative to standard JWT - see security notes)
JWT_SECRET_KEY={keys_dict['jwt_secret']}
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=15
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# Symmetric Encryption (Fernet)
SECRET_ENCRYPTION_KEY={keys_dict['fernet_key']}

# Session Management
SESSION_SECRET_KEY={keys_dict['session_secret']}

# RSA Key Pair (OpenSSL Generated)
RSA_PRIVATE_KEY_PEM={keys_dict['private_key_base64']}
RSA_PUBLIC_KEY_PEM={keys_dict['public_key_base64']}

# Security Settings
SECURITY_LEVEL=high
ENFORCE_HTTPS=true
SECURE_COOKIES=true
CSRF_PROTECTION=true
RATE_LIMITING=true

# Redis Configuration (for distributed sessions)
# REDIS_URL=redis://localhost:6379/0

# Alternative Authentication Methods (More Secure than JWT)
# Consider implementing these for enhanced security:
USE_OAUTH2_PKCE=true
USE_WEBAUTHN=true
USE_TOTP_MFA=true

# Certificate-based Authentication (Future Implementation)
# ENABLE_CERT_AUTH=true
# CLIENT_CERT_REQUIRED=true
"""
    return template

def generate_oauth2_encryption_key():
    """Generate OAuth2 PKCE encryption key using Fernet"""
    print("üîê Generating OAuth2 PKCE encryption key...")
    return Fernet.generate_key().decode()

def generate_oauth2_client_id():
    """Generate secure OAuth2 client ID"""
    print("üîê Generating OAuth2 client ID...")
    return f"crm_{secrets.token_urlsafe(16)}"

def create_oauth2_env_template(keys_dict):
    """Create .env template with OAuth2 PKCE configuration"""
    template = f"""# ========================================
# CRM OAuth2 PKCE Security Configuration
# ========================================
# Generated by secure key generation script
# CRITICAL: Keep these keys secure and never commit to version control

# Database Configuration
DATABASE_URL=sqlite:///./crm_production.db
# For PostgreSQL: DATABASE_URL=postgresql://user:password@localhost:5432/crm_db

# ========================================
# OAuth 2.0 with PKCE Configuration
# ========================================

# OAuth2 Encryption Key (for token encryption)
OAUTH2_ENCRYPTION_KEY={keys_dict['oauth2_encryption_key']}

# OAuth2 Server URLs
OAUTH2_AUTHORIZATION_URL=https://your-domain.com/auth/authorize
OAUTH2_TOKEN_URL=https://your-domain.com/auth/token
OAUTH2_USERINFO_URL=https://your-domain.com/auth/userinfo

# OAuth2 Token Configuration
OAUTH2_ACCESS_TOKEN_EXPIRE_MINUTES=60
OAUTH2_REFRESH_TOKEN_EXPIRE_DAYS=30
OAUTH2_AUTHORIZATION_CODE_EXPIRE_MINUTES=10

# OAuth2 Client Configuration
OAUTH2_DEFAULT_CLIENT_ID={keys_dict['oauth2_client_id']}
OAUTH2_ALLOWED_SCOPES=read,write,admin,sales,marketing,support
OAUTH2_REDIRECT_URIS=https://your-domain.com/auth/callback,http://localhost:3000/auth/callback

# ========================================
# Security Configuration
# ========================================

# Session Encryption Key
SECRET_ENCRYPTION_KEY={keys_dict['fernet_key']}

# Session Management
SESSION_SECRET_KEY={keys_dict['session_secret']}

# RSA Key Pair (OpenSSL Generated)
RSA_PRIVATE_KEY_PEM={keys_dict['private_key_base64']}
RSA_PUBLIC_KEY_PEM={keys_dict['public_key_base64']}

# Environment Settings
ENVIRONMENT=production
SECURE_COOKIES=true
HTTPS_ONLY=true
CORS_ORIGINS=https://your-domain.com,https://app.your-domain.com

# Security Settings
SECURITY_LEVEL=high
ENFORCE_HTTPS=true
CSRF_PROTECTION=true
RATE_LIMITING=true

# ========================================
# DEPRECATED JWT Configuration
# ========================================
# These are kept for reference but should NOT be used
# The system has been migrated to OAuth 2.0 with PKCE

# JWT_SECRET_KEY=DEPRECATED_USE_OAUTH2_PKCE
# JWT_ALGORITHM=DEPRECATED_USE_OAUTH2_PKCE
# JWT_ACCESS_TOKEN_EXPIRE_MINUTES=DEPRECATED_USE_OAUTH2_PKCE

# ========================================
# Advanced Security Features
# ========================================

# Multi-Factor Authentication
ENABLE_MFA=true
TOTP_ISSUER=CRM_Application

# WebAuthn/FIDO2 Support
ENABLE_WEBAUTHN=true
WEBAUTHN_RP_ID=your-domain.com
WEBAUTHN_RP_NAME=CRM Application

# Certificate-based Authentication
ENABLE_CERT_AUTH=false
CLIENT_CERT_REQUIRED=false

# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_REQUESTS_PER_MINUTE=60

# Audit and Logging
AUDIT_LOG_ENABLED=true
SECURITY_LOG_ENABLED=true
PERFORMANCE_MONITORING=true
"""
    return template

def generate_oauth2_keys():
    """Generate all OAuth2 PKCE related keys"""
    print("üöÄ Starting OAuth2 PKCE key generation...")
    
    keys = {}
    
    # Generate OAuth2 specific keys
    keys['oauth2_encryption_key'] = generate_oauth2_encryption_key()
    keys['oauth2_client_id'] = generate_oauth2_client_id()
    
    # Generate other required keys
    keys['fernet_key'] = generate_secure_symmetric_key()
    keys['session_secret'] = generate_session_secret()
    
    # Generate RSA key pair using OpenSSL
    try:
        private_key_pem, public_key_pem = generate_openssl_rsa_keys()
        keys['private_key_base64'] = base64.b64encode(private_key_pem.encode()).decode()
        keys['public_key_base64'] = base64.b64encode(public_key_pem.encode()).decode()
        print("‚úÖ RSA keys generated successfully")
    except Exception as e:
        print(f"‚ö†Ô∏è  OpenSSL not available, falling back to cryptography library")
        # Fallback to cryptography library
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_pem = private_key.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        keys['private_key_base64'] = base64.b64encode(private_pem).decode()
        keys['public_key_base64'] = base64.b64encode(public_pem).decode()
    
    return keys

def main():
    """Generate all security keys and create configuration"""
    print("üöÄ Starting secure key generation for CRM application...")
    print("üìã This will generate production-ready cryptographic keys using OpenSSL standards")
    
    # Generate all keys
    keys = {}
    
    # Generate RSA key pair using OpenSSL
    try:
        private_key_pem, public_key_pem = generate_openssl_rsa_keys()
        keys['private_key_base64'] = base64.b64encode(private_key_pem.encode()).decode()
        keys['public_key_base64'] = base64.b64encode(public_key_pem.encode()).decode()
        print("‚úÖ RSA keys generated successfully")
    except Exception as e:
        print(f"‚ö†Ô∏è  OpenSSL not available, falling back to cryptography library")
        # Fallback to cryptography library
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_pem = private_key.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        keys['private_key_base64'] = base64.b64encode(private_pem).decode()
        keys['public_key_base64'] = base64.b64encode(public_pem).decode()
    
    # Generate symmetric keys
    keys['fernet_key'] = generate_secure_symmetric_key()
    keys['jwt_secret'] = generate_jwt_secret()
    keys['session_secret'] = generate_session_secret()
    
    # Create .env file
    env_content = create_env_template(keys)
    
    # Write to .env.secure file (don't overwrite existing .env)
    env_file = Path("../.env.secure")
    with open(env_file, 'w') as f:
        f.write(env_content)
    
    print(f"‚úÖ Secure configuration written to {env_file}")
    print("\nüìã Next Steps:")
    print("1. Review the generated .env.secure file")
    print("2. Backup your current .env file")
    print("3. Rename .env.secure to .env")
    print("4. Restart your application")
    print("\n‚ö†Ô∏è  Security Notes:")
    print("- Keep these keys secure and never commit to version control")
    print("- Consider using environment-specific key management systems")
    print("- Rotate keys regularly (every 90 days recommended)")
    print("- Consider JWT alternatives for enhanced security")

if __name__ == "__main__":
    main()
